

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="where">
  <meta name="keywords" content="">
  
    <meta name="description" content="ChatGPT问答云原生概念云原生（Cloud Native）是一种软件开发和部署的方法论，旨在在云计算环境下构建和运行应用程序。它强调将应用程序设计为适应云架构的特点，并提供了在云环境中构建、交付和运行应用程序的最佳实践。 云原生应用具有以下几个主要特点：  微服务架构：云原生倡导将应用程序拆分成小而自治的服务（称为微服务），每个服务专注于完成一个特定的业务功能。这使得应用程序更加模块化、可扩展">
<meta property="og:type" content="article">
<meta property="og:title" content="ChatGPT问答">
<meta property="og:url" content="http://example.com/2023/07/07/%E5%AD%A6%E4%B9%A0+%E7%96%91%E6%83%91/ChatGPT%E9%97%AE%E7%AD%94/index.html">
<meta property="og:site_name" content="where&#39;s blog">
<meta property="og:description" content="ChatGPT问答云原生概念云原生（Cloud Native）是一种软件开发和部署的方法论，旨在在云计算环境下构建和运行应用程序。它强调将应用程序设计为适应云架构的特点，并提供了在云环境中构建、交付和运行应用程序的最佳实践。 云原生应用具有以下几个主要特点：  微服务架构：云原生倡导将应用程序拆分成小而自治的服务（称为微服务），每个服务专注于完成一个特定的业务功能。这使得应用程序更加模块化、可扩展">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-07-07T02:00:00.000Z">
<meta property="article:modified_time" content="2023-09-12T01:06:37.906Z">
<meta property="article:author" content="where">
<meta property="article:tag" content="分布式系统">
<meta property="article:tag" content="学习">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>ChatGPT问答 - where&#39;s blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="ChatGPT问答"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-07-07 10:00" pubdate>
          2023年7月7日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          19k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          159 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">ChatGPT问答</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="ChatGPT问答"><a href="#ChatGPT问答" class="headerlink" title="ChatGPT问答"></a>ChatGPT问答</h1><h1 id="云原生"><a href="#云原生" class="headerlink" title="云原生"></a>云原生</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>云原生（Cloud Native）是一种软件开发和部署的方法论，旨在在云计算环境下构建和运行应用程序。它强调将应用程序设计为适应云架构的特点，并提供了在云环境中构建、交付和运行应用程序的最佳实践。</p>
<p>云原生应用具有以下几个主要特点：</p>
<ol>
<li><p>微服务架构：云原生倡导将应用程序拆分成小而自治的服务（称为微服务），每个服务专注于完成一个特定的业务功能。这使得应用程序更加模块化、可扩展和可维护，并能够更好地适应云环境中的变化。</p>
</li>
<li><p>弹性伸缩：云原生应用可以根据负载情况进行动态扩展或缩减。它们能够自动适应变化的资源需求，确保应用程序在需要时具有足够的能力来满足用户需求，并在需求减少时节省资源成本。</p>
</li>
<li><p>容器化部署：云原生将应用程序及其依赖项打包成容器，例如 Docker 容器。容器提供了一种轻量级、一致性和可移植性的部署单元，并可以在不同的平台和环境中进行部署，确保应用程序的可靠性和可复制性。</p>
</li>
<li><p>自动化管理：云原生应用使用自动化工具和平台来管理应用程序的构建、部署、监控和运维。自动化流程可以降低操作复杂性，提高开发和运维效率，并增加应用程序的可靠性和稳定性。</p>
</li>
</ol>
<p>为什么叫云原生呢？因为云原生应用是专为云环境而设计的，它充分利用云计算提供的资源弹性、可伸缩性和自动化特性，以更好地满足当今动态和分布式的应用需求。云原生是为了让应用程序在云环境中发</p>
<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>云原生（Cloud Native）是一种软件架构和开发方式，旨在构建可弹性扩展、高可用、灵活的分布式应用，以充分发挥云计算的优势。在云原生架构中，通常包含以下几个核心模块和相应的工具：</p>
<ol>
<li><p>容器化（Containerization）：<br>容器化是将应用程序和其所有依赖项（例如库、运行环境）打包到一个独立的轻量级容器中的过程。主要用于实现应用的隔离、可移植性和可重复部署。常用的容器化工具有Docker和Containerd。</p>
</li>
<li><p>编排和调度（Orchestration and Scheduling）：<br>编排和调度工具用于自动管理和调度大规模容器化应用程序的部署和执行。它们负责资源分配、负载均衡、容器编排、服务发现等。常用的编排和调度工具有Kubernetes和Apache Mesos。</p>
</li>
<li><p>服务网格（Service Mesh）：<br>服务网格是一种用于管理不同服务之间通信的基础设施层。它负责智能地处理服务之间的流量路由、服务发现、负载均衡、熔断等通信方面的功能。常用的服务网格工具有Istio和Linkerd。</p>
</li>
<li><p>无服务器计算（Serverless Computing）：<br>无服务器计算是一种基于事件触发的计算范式，允许开发人员以函数为单位编写和执行代码，而无需关注底层的基础设施管理。常用的无服务器计算工具有AWS Lambda和Azure Functions。</p>
</li>
<li><p>持续集成与持续部署（Continuous Integration and Continuous Deployment）：<br>持续集成与持续部署工具用于自动化构建、测试和交付应用程序。它们可以确保应用程序代码的质量，加快开发迭代，实现快速部署和稳定交付。常用的工具有Jenkins和GitLab CI&#x2F;CD。</p>
</li>
</ol>
<p>以上是云原生架构中的一些核心模块和相应的工具。它们通过配合使用，可帮助开发人员构建弹性、可靠和可伸缩的应用程序，并利用云计算的优势迅速响应业务需求。需要根据具体的场景和需求选择适合的工具和技术组合。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure>

<h1 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h1><h2 id="分布式系统概述"><a href="#分布式系统概述" class="headerlink" title="分布式系统概述"></a>分布式系统概述</h2><p>分布式系统由多个模块和内容组成，其中一些常见的包括：</p>
<ol>
<li><p>通信模块：<br>分布式系统需要一个可靠的通信模块，用于节点之间的通信和消息传递。这可能涉及网络协议、消息传递接口、远程过程调用（RPC）等。</p>
</li>
<li><p>分布式存储：<br>分布式系统通常需要分布式存储来处理大量数据的存储和访问。这可能包括分布式文件系统、分布式数据库、分布式键值存储等。</p>
</li>
<li><p>分布式计算：<br>分布式系统需要能够将计算任务分配到不同的计算节点上进行并行处理。这可能涉及分布式计算框架、分布式任务调度、分布式计算模型等。</p>
</li>
<li><p>分布式一致性和协调：<br>分布式系统在面对并发请求和多个节点之间的状态同步时，需要一致性和协调机制来保持数据一致和处理并发冲突。这包括分布式事务、分布式锁、一致性协议等。</p>
</li>
<li><p>分布式监控和管理：<br>分布式系统需要监控和管理工具来实时监测系统的健康状态、性能指标和错误日志。这可能涉及分布式日志管理、分布式追踪、分布式监控系统等。</p>
</li>
<li><p>负载均衡和容错机制：<br>分布式系统经常需要负载均衡和容错机制，以实现资源的平衡和提高系统的可用性。这包括负载均衡算法、故障转移、容错处理、自动缩放等。</p>
</li>
<li><p>安全和身份验证：<br>分布式系统需要提供安全机制来保护数据的机密性和完整性。这可能包括身份验证、访问控制、数据加密、安全通信协议等。</p>
</li>
<li><p>分布式调度和任务管理：<br>分布式系统可能需要一套调度和管理机制，用于协调和执行各个计算节点上的任务。这包括任务分配、调度策略、任务管理器等。</p>
</li>
<li><p>分布式缓存：<br>分布式系统通常会使用分布式缓存来提高数据访问的性能和效率。这可能包括分布式缓存框架、缓存一致性算法、缓存失效策略等。</p>
</li>
<li><p>分布式搜索和索引：<br>如果分布式系统涉及大规模的数据搜索和索引，就需要针对这些需求进行特定的模块和内容设计。这可能包括分布式搜索引擎、分布式索引库、分布式全文搜索等。</p>
</li>
<li><p>分布式任务队列和消息中间件：<br>分布式系统中常常需要使用任务队列和消息中间件来实现异步任务处理和消息传递。这可以包括分布式任务队列、消息队列、事件总线等。</p>
</li>
<li><p>分布式缓存一致性和失效策略：<br>分布式系统使用缓存时，需要考虑缓存一致性和失效策略，以确保数据的准确性和及时性。这涉及到分布式缓存同步、缓存失效机制、缓存更新策略等。</p>
</li>
<li><p>分布式调度器和资源管理：<br>如果分布式系统涉及到资源调度和管理，需要使用分布式调度器和资源管理器来合理分配和管理系统资源。这可能包括分布式作业调度、资源分配策略、容器编排等。</p>
</li>
<li><p>分布式日志和跟踪：<br>分布式系统需要对各个节点的日志进行收集和分析，以便进行故障排查和系统监控。这可能涉及分布式日志收集、分布式跟踪和调用链监控等。</p>
</li>
<li><p>分布式任务协作和通信：<br>在分布式系统中，节点之间需要进行任务协作和通信。这可能包括分布式任务分发、消息传递、状态同步等。</p>
</li>
</ol>
<p>以上列出的模块和内容并不是固定的，实际的分布式系统可能根据具体的需求和设计选择性地使用这些模块，或者根据实际情况进行适当的调整和扩展。分布式系统的设计和实现是一个复杂的领域，需要综合考虑各种因素并进行合理的权衡和优化。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure>





<h2 id="一致性协议"><a href="#一致性协议" class="headerlink" title="一致性协议"></a>一致性协议</h2><p>分布式一致性协议的作用是在分布式系统中，确保在不同节点之间的数据副本一致性，以防止数据冲突和不一致的情况发生。它确保所有节点对数据的读和写操作都满足一致性要求，从而使分布式系统能够可靠地工作。</p>
<p>以下是几个实际的例子，展示了分布式一致性协议的用途：</p>
<ol>
<li><p>Paxos 协议：<br>Paxos 是一种经典的分布式一致性协议，用于解决在具有故障节点的分布式系统中达成一致的问题。它确保多个节点在宕机和网络故障的情况下仍能就某个值达成一致，并保证了系统的可靠性和一致性。Paxos 协议在各种分布式系统中被广泛应用，比如分布式数据库的复制和一致性保证。</p>
</li>
<li><p>Raft 协议：<br>Raft 是另一个分布式一致性协议，与 Paxos 类似，旨在解决分布式系统中的一致性问题。它通过引入领导者（Leader）和跟随者（Follower）的角色来确保多个节点之间的数据一致性。Raft 协议的应用场景包括分布式存储系统、分布式锁服务等。</p>
</li>
<li><p>ZooKeeper：<br>ZooKeeper 是一个分布式协调服务，它采用了一些一致性协议来管理和协调分布式系统中的各种任务和资源。它提供了一致性访问、命名服务、分布式锁等功能，使得分布式系统的组件能够协同工作。</p>
</li>
</ol>
<p>这些是分布式一致性协议的一些例子，它们在分布式系统中起着关键的作用，确保系统的数据一致性、可靠性和可用性。通过使用这些协议，分布式系统</p>
<h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><p>在分布式系统中的复制是指将数据在多个节点间进行副本复制，以提高系统的可用性、容错性和性能。复制方案可以根据复制的参与者、副本的数量和复制的数据一致性级别来分类。以下是几种常见的复制方案及其优缺点：</p>
<ol>
<li><p>主从复制（Master-Slave Replication）：</p>
<ul>
<li>方案：主从复制中有一个主节点（Master）和多个从节点（Slaves）。主节点负责处理所有的写操作，并将写操作的结果异步地复制到从节点上。</li>
<li>优点：<ul>
<li>提高读性能：从节点可以处理读操作，分担主节点的负载。</li>
<li>容错性：即使主节点发生故障，从节点仍然可以提供读服务。</li>
</ul>
</li>
<li>缺点：<ul>
<li>写性能受限：所有的写操作都需要通过主节点进行，可能成为瓶颈。</li>
<li>数据一致性延迟：主从节点间的复制存在一定的延迟，可能导致从节点中的数据不是实时最新的。</li>
</ul>
</li>
</ul>
</li>
<li><p>多主复制（Multi-Master Replication）：</p>
<ul>
<li>方案：多主复制中有多个主节点，每个主节点都可以独立地处理读写操作，并将写操作异步地复制到其他主节点。</li>
<li>优点：<ul>
<li>提高读写性能：多个主节点可以并行地处理读写操作，提高了系统的吞吐量。</li>
<li>增加容错性：即使某个主节点发生故障，其他主节点仍可以继续提供写操作。</li>
</ul>
</li>
<li>缺点：<ul>
<li>写冲突：多主节点之间的并行写操作可能导致冲突和数据一致性问题。</li>
<li>冲突解决：需要实现复杂的冲突检测和解决策略，确保数据的一致性。</li>
</ul>
</li>
</ul>
</li>
<li><p>全复制（Full Replication）：</p>
<ul>
<li>方案：在全复制中，所有节点都包含完整的数据副本，并且每个节点都可以处理读写操作。</li>
<li>优点：<ul>
<li>最高的读写性能：每个节点都可以独立地处理读写操作。</li>
<li>最高的容错性：即使多个节点发生故障，系统仍然可以继续提供读写服务。</li>
</ul>
</li>
<li>缺点：<ul>
<li>存储成本：需要更多的存储空间，以存储数据的完整副本。</li>
<li>写延迟：所有节点都需要在写操作上达成一致，可能导致写操作的延迟。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>这些复制方案各有优劣，选择适合的方案需要权衡系统的可用性、一致性和性能需求。常见的一些技术，如数据分区、冲突解决和数据一致性协议（例如 Paxos、Raft 等）可以用来解决复制过程中的一致性和冲突问题。</p>
<h2 id="分片分区"><a href="#分片分区" class="headerlink" title="分片分区"></a>分片分区</h2><p>在分布式系统中，分片（Sharding）和分区（Partitioning）是两个相关的概念，用于将数据拆分成多个片段或区域以实现扩展性和性能的提升。</p>
<ol>
<li><p>分片（Sharding）：<br>分片是将数据集合划分成多个较小的片段（Shard），每个片段可以存储在不同的节点或数据存储介质上。每个片段通常是根据某个数据属性的特定规则进行划分，例如按照数据范围、哈希函数或轮询分片等。</p>
<p>分片的好处是可以水平扩展数据存储和处理能力，以处理大规模数据集和高并发负载。每个分片可以由独立的节点或数据库实例承载，从而提供更好的性能和可伸缩性。分片还可以提高系统的容错性，因为故障发生时只有受影响的分片受到影响。</p>
<p>分片方案一般涉及到数据路由算法和负载均衡技术，以确保数据能够正确地路由到对应的分片，并且在不同分片间均衡地分配负载。</p>
</li>
<li><p>分区（Partitioning）：<br>分区是将数据集合划分成多个逻辑区域或段，每个分区通常包含一部分数据和关联的处理逻辑。与分片不同，分区的目的是将数据按特定的业务需求进行逻辑划分，而不一定需要将它们存储在不同的物理节点上。</p>
<p>分区可以根据数据的某个关键属性进行划分，如用户ID、时间范围、地理位置等。每个分区可以被单独地处理和查询，从而提高处理效率和减少系统间的竞争。</p>
<p>分区方案通常涉及到数据路由和查询优化技术，以确保查询只搜索所需的分区，而不会浪费资源搜索整个数据集。</p>
</li>
</ol>
<p>常见的分片和分区方案包括：</p>
<ol>
<li><p>哈希分片（Hash Sharding）：根据数据的哈希值来确定数据所在的分片。例如，可以将数据的主键经过哈希函数计算得到哈希值，再根据哈希值来确定数据所在的分片。</p>
</li>
<li><p>范围分区（Range Partitioning）：根据数据的范围将数据划分到不同的分区。例如，可以根据指定的范围条件来将数据划分到相应的分区，例如按照创建时间将数据划分到不同的时间段分区。</p>
</li>
<li><p>一致性哈希（Consistent Hashing）：将数据和节点都映射到一个环上，然后通过哈希函数将数据映射到环上的一个节点上。当需要对数据进行分片时，可以根据节点在环上的位置来确定数据所属的节点。</p>
</li>
<li><p>垂直分区（Vertical Partitioning）：将数据按照属性或关系模式进行划分，每个分区只包含一部分属性或关系。常用于将频繁访问的属性或关系放在一个分区中，以提高查询性能。</p>
</li>
<li><p>水平分区（Horizontal Partitioning）：将数据按照行划分到多个分区中，每个分区存储一部分数据行。常用于解决数据量过大的问题，提高查询性能和并行处理能力。</p>
</li>
<li><p>复制分片（Replication Sharding）：将数据复制到多个节点中，每个节点都存储完整的数据。常用于提高系统的可用性和容错性，防止单点故障。</p>
</li>
</ol>
<p>这些分片和分区方案可以根据实际需求和系统特点进行选择和组合。不同的方案适用于不同的场景，可以根据数据的特性、负载均衡需求、可用性需求和查询性能等因素来进行权衡和决策。</p>
<h3 id="案例ElasticSearch"><a href="#案例ElasticSearch" class="headerlink" title="案例ElasticSearch"></a>案例ElasticSearch</h3><p>在 Elasticsearch 中，我们可以使用分区和分片来管理和优化数据索引和查询。例如，我们可以将一个包含用户信息的索引按用户的地理位置进行分区。每个分区可以代表一个地理区域，例如按国家、州或城市划分。这样做有以下好处：</p>
<ol>
<li><p>数据本地化：将用户数据分区可以使得数据更接近用户所在的地理位置，从而提供更快的查询响应时间。</p>
</li>
<li><p>查询优化：当我们执行与特定地理区域相关的查询时，只需在相关的分区中执行查询操作，而不需要搜索整个索引。这提高了查询性能并减少了不必要的资源消耗。</p>
</li>
</ol>
<p>另外，每个索引分区可以进一步划分为多个分片。例如，对于每个用户地理位置分区，我们可以根据用户ID进行分片。这样做有以下好处：</p>
<ol>
<li><p>数据均衡和可伸缩性：将数据分片可以使得数据在集群中均匀分布，从而实现负载均衡。如果集群中新增节点，可以将一部分分片分配给新节点，并将负载分散。</p>
</li>
<li><p>并行查询和高吞吐量：当执行查询时，可以在多个分片上并行执行操作，从而提高查询吞吐量和响应时间。</p>
</li>
</ol>
<p>需要注意的是，分区和分片需要根据具体场景和数据访问模式进行设计和配置。合理的分区和分片策略可以提高性能和可用性，但过度细分也可能引发复杂性和性能问题。</p>
<p>总结来说，通过分区和分片的组合，我们可以在 Elasticsearch 集群中实现数据的本地化、并行查询和负载均衡，以提高系统性能和可伸缩性。</p>
<h2 id="分布式时间"><a href="#分布式时间" class="headerlink" title="分布式时间"></a>分布式时间</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>分布式系统中时间的概念非常重要，它用于协调和管理分布式系统中各个节点的操作和事件顺序。正确使用时间可以帮助解决分布式系统中的一致性、并发和调度等问题。</p>
<p>为什么使用分布式时间？</p>
<ol>
<li><p>事件顺序：在分布式系统中，由于网络延迟和节点间的异步操作，无法全局确定事件的确切发生顺序。使用分布式时间可以提供一个全局有序的时间轴，并确保系统中的事件按照正确的顺序进行处理。</p>
</li>
<li><p>一致性保证：许多分布式算法和协议，例如分布式事务、一致性哈希等，依赖于时间作为参考点来实现一致性保证。使用正确的时间可以确保分布式系统的数据和状态保持一致。</p>
</li>
</ol>
<p>如何正确使用分布式时间？</p>
<ol>
<li>时钟同步：确保各个节点的时钟尽可能地同步，以减小时钟漂移和误差。常见的时钟同步协议如NTP（Network Time Protocol）可用于同步系统时钟。</li>
<li>使用逻辑时钟：逻辑时钟是一种基于事件顺序的时间表示方式，如Lamport时钟和向量时钟。通过在每个事件上定义序列号或向量，可以确定事件的先后顺序。</li>
<li>物理时钟和时钟服务：分布式系统中常使用的是物理时钟，如系统时钟或硬件时钟。许多云平台和分布式系统提供时钟服务（例如Google的TrueTime和AWS的AWS TimeSync），可以提供更精确的时间来解决时钟漂移和误差问题。</li>
</ol>
<h3 id="全局、逻辑、物理时钟"><a href="#全局、逻辑、物理时钟" class="headerlink" title="全局、逻辑、物理时钟"></a>全局、逻辑、物理时钟</h3><p>全局时钟、逻辑时钟和物理时钟是在分布式系统和并发编程中用来记录和同步时间的不同概念。</p>
<ol>
<li>全局时钟：全局时钟是指能够为整个分布式系统提供全局时间的时钟。它是一个单一的时钟，能够为系统中的所有节点提供一个统一的时间参考，使得所有节点的事件按照相同的时间顺序发生。然而，实现全局时钟在分布式系统中往往非常困难，并且有时会受到网络延迟和时钟漂移等因素的影响。</li>
</ol>
<p>使用场景：全局时钟在一些需要精确时间戳排序的分布式应用中可能会有用，如分布式事务和分布式日志记录。</p>
<ol start="2">
<li>逻辑时钟：逻辑时钟是一种用于在分布式系统中记录事件顺序的抽象概念。它不依赖于真实的物理时间，而是通过逻辑计数器来表示事件的顺序。逻辑时钟通常有两种类型：Lamport时钟和向量时钟。</li>
</ol>
<p>Lamport时钟：Lamport时钟通过每个节点上的递增计数器来表示事件的顺序，并通过事件之间的消息传递来更新计数器。Lamport时钟不能解决因网络延迟而引起的事件顺序问题。</p>
<p>向量时钟：向量时钟通过为每个节点维护一个向量来记录事件的顺序，向量的每个维度对应一个节点，向量中的每个值表示该节点看到的其他节点的事件数。向量时钟可以更精确地表示事件的顺序，并解决因网络延迟而引起的事件顺序问题。</p>
<p>使用场景：逻辑时钟可以应用于一些需要事件顺序的分布式应用，如因果一致性和分布式快照<br>3. 物理时钟（续）：物理时钟是通过硬件设备来提供真实的时间信息，如计算机上的时钟模块。物理时钟通常通过硬件定时器来提供一个递增的时间序列，并通过操作系统的时钟中断来更新时间。但在分布式系统中，由于各个节点的时钟漂移和不一致性，物理时钟无法保证事件顺序的一致性。物理时钟通常用于记录事件的真实时间戳，但不能作为分布式系统中事件顺序的唯一依据。</p>
<p>使用场景：物理时钟适用于需要实时时间戳、日志记录等需要基于真实时间的应用场景中。</p>
<p>实现案例和协议：</p>
<ol>
<li><p>NTP（网络时间协议）：NTP是一个用于通过网络同步计算机时钟的协议。它通过客户端和服务器之间的时间同步交互，使得计算机的时钟能够与基于真实时间的时钟源（如原子钟）保持一致。</p>
</li>
<li><p>Lamport时钟和向量时钟：Lamport时钟和向量时钟是逻辑时钟的典型实现。Lamport时钟由Leslie Lamport于1978年提出，向量时钟则由Colin Fidge于1988年提出。它们的实现在分布式系统中广泛应用，如分布式数据库、分布式共享内存和一致性协议等。</p>
</li>
</ol>
<p>总结：</p>
<ul>
<li>全局时钟能够为整个分布式系统提供统一的时间参考，但实现复杂且受网络延迟和时钟漂移等因素影响。</li>
<li>逻辑时钟是一种抽象概念，用于记录事件顺序，如Lamport时钟和向量时钟。它们通过递增计数器或向量来实现，并解决了事件顺序问题。</li>
<li>物理时钟是真实的计时设备，用于提供实时的时间信息，但在分布式系统中由于时钟漂移和不一致性，无法保证事件顺序的一致性。</li>
</ul>
<p>请注意，具体使用哪种时钟取决于具体的应用场景和需求。在实际开发中，可以根据需要设计和选择合适的时钟机制来满足分布式系统的要求。</p>
<h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p>NTP（Network Time Protocol）协议和Lamport时钟是两个与时间同步和事件顺序相关的概念和技术。下面是对NTP协议和Lamport时钟的介绍、原理、使用场景和使用案例的说明：</p>
<p>NTP协议：<br>NTP（Network Time Protocol）是一种用于网络中时间同步的协议。它允许计算机通过网络同步其时钟，以便在分布式系统中保持一致的时间。NTP协议通过客户端和服务器之间的时间同步交互，使得计算机的时钟能够与基于真实时间的时钟源（如原子钟）保持一致。</p>
<p>原理：<br>NTP协议基于主从架构，其中服务器充当时间源，提供准确的时间。客户端通过NTP请求与服务器进行时间同步，并根据服务器提供的时间调整自身的时钟。NTP使用一种校正算法来估计网络延迟，并计算出客户端时钟的偏差，以进行时钟同步。</p>
<p>使用场景：<br>NTP协议广泛用于需要时间同步和一致性的分布式系统和网络环境。以下是一些常见的使用场景：</p>
<ol>
<li>计算机网络中的时钟同步。</li>
<li>分布式数据库和存储系统中的一致性控制。</li>
<li>跨地理区域的服务器集群中的事件时间戳。</li>
<li>金融交易系统中需要精确的时间戳。</li>
</ol>
<p>使用案例：</p>
<ol>
<li>企业内部网络时间同步：一个企业可能有多个部门和地理位置，使用NTP协议可以在企业内部网络中同步所有计算机的时钟，确保一致性。</li>
<li>金融交易系统：金融交易系统对于交易的时间戳和事件顺序非常敏感，NTP协议可以确保各个交易节点的时钟保持同步，以维持系统的准确性和一致性。</li>
</ol>
<p>Lamport时钟：<br>Lamport时钟是一种逻辑时钟，用于在分布式系统中记录事件的发生顺序。它不依赖于真实的物理时间，而是通过逻辑计数器表示事件的顺序。Lamport时钟由Leslie Lamport在1978年提出。</p>
<p>原理：<br>Lamport时钟通过每个节点上的递增计数器来记录事件发生的顺序。当节点发生本地事件时，它会将自己的时钟值加一。当节点发送消息给其他节点时，也会将自己的时钟值附在消息中。接收到消息的节点会比较消息中的时钟值和自己的时钟值，然后将自己的时钟值更新为两者中较大的那个。</p>
<p>使用场景：<br>Lamport时钟适用于一些需要确定事件发生顺序的分布式系统，例如：</p>
<ol>
<li>分布式共享内存系统，通过确定读写操作的顺序来维护一致性。</li>
<li>分布式数据库，通过确定事务的提交顺序来维护数据一致性。</li>
<li>分布式算法和协议，如分布式锁、一致性算法等。</li>
</ol>
<p>使用案例：</p>
<ol>
<li>Chubby锁服务：Google的Chubby锁服务使用Lamport时钟来维护全局的锁次序。每个节点在持有锁时使用Lamport时钟更新锁的版本号，以确保分布式环境中的锁顺序一致性。</li>
<li>基于消息队列的应用：在使用消息队列的系统中，通过Lamport时钟可以确定消息的处理顺序，确保消息按照正确的先后顺序处理。</li>
</ol>
<p>总结：<br>NTP协议是通过网络同步计算机的时钟，用于确保分布式系统中的时间一致性。而Lamport时钟是一种逻辑时钟，通过递增计数器记录事件的发生顺序，用于确定分布式系统中事件的顺序。这两种技术在分布式系统中具有不同的应用场景和用途。</p>
<h3 id="Flink的时间"><a href="#Flink的时间" class="headerlink" title="Flink的时间"></a>Flink的时间</h3><p>以Flink流计算为例的时间概念：</p>
<p>Flink是一个分布式流处理和批处理框架，具有强大的事件驱动模型和时间处理能力。</p>
<ol>
<li><p>Event Time：Flink允许使用事件生成的时间（Event Time）而不是处理时间（Processing Time）来进行流计算。通过使用事件生成的时间（Event Time），Flink可以正确处理来自分布式系统中不同节点的事件数据，解决了事件的乱序和延迟问题。Event Time可以根据事件本身的时间戳来确定事件的顺序，而不依赖于处理事件的时间或顺序。</p>
</li>
<li><p>Watermark：Flink使用Watermark来度量事件流的进展，并确保事件按照正确的时间先后顺序进行处理。Watermark是一个具有时间戳的特殊事件，用于告知系统事件流的进展情况。Flink在处理事件时，会根据Watermark来判断事件是否滞后，并启动按时间窗口进行的计算和操作。</p>
</li>
<li><p>Window：Flink中的Window是按时间范围对事件数据进行分组和处理的机制。Window可以根据不同的时间概念进行划分，如滚动窗口（Tumbling Window）、滑动窗口（Sliding Window）和会话窗口（Session Window）。这些窗口根据事件的时间戳将事件数据划分为不同的窗口，以便对窗口中的事件进行计算和聚合操作。</p>
</li>
</ol>
<p>对于分布式时间的提出者Leslie Lamport提出了Lamport时钟概念。Lamport时钟是一种逻辑时钟的实现方式，它通过在每个事件上为其分配一个递增的时间戳来定义事件的顺序。Lamport时钟没有对时间的精确度做出任何保证，只保证了事件的偏序关系，即能够确定事件的先后顺序，而无法确定事件的具体时间点。</p>
<p>无论是Flink中的事件时间处理还是Lamport时钟，它们都<strong>为分布式系统提供了一致的时间概念和事件顺序，以便于正确处理和调度分布式系统中的事件和操作</strong>。通过合理使用分布式时间，我们可以准确处理分布式系统中的数据、保证数据一致性并提高系统的性能和可扩展性。</p>
<h3 id="Flink采用逻辑时钟的原因"><a href="#Flink采用逻辑时钟的原因" class="headerlink" title="Flink采用逻辑时钟的原因"></a>Flink采用逻辑时钟的原因</h3><p>Flink作为一个流处理和批处理框架，采用逻辑时钟是为了在分布式环境下实现事件顺序的准确性和一致性。下面是Flink采用逻辑时钟的原因：</p>
<ol>
<li><p>事件时间处理：Flink支持基于事件时间（Event Time）的处理，这是为了在处理具有时间属性的数据时能够准确地维护时间的语义。逻辑时钟在Flink中用于确定事件发生的顺序，并为每个事件分配一个时间戳，确保数据按照正确的事件顺序进行处理。</p>
</li>
<li><p>处理延迟和乱序数据：在分布式流处理中，数据的到达时间和顺序可能会因为网络延迟或分布式环境的限制而产生较大的变化。逻辑时钟可以帮助Flink对乱序的数据进行重新排序，以确保事件的处理顺序是正确的，并且可以处理延迟到达的数据。</p>
</li>
<li><p>窗口操作和状态管理：Flink中的窗口操作和状态管理依赖于事件的时间顺序。通过逻辑时钟，Flink可以正确地根据时间窗口将事件分配到对应的窗口中，实现窗口操作和状态管理的准确性和一致性。</p>
</li>
<li><p>故障恢复和一致性保证：Flink支持故障恢复和容错机制，其中逻辑时钟在事件的检查点（Checkpoint）和恢复过程中扮演重要角色。逻辑时钟的正确性和一致性可以确保在故障发生后的恢复过程中，事件的顺序和状态一致性得到保证。</p>
</li>
</ol>
<p>总结：<br>Flink采用逻辑时钟是为了实现事件时间处理、处理延迟和乱序数据、窗口操作和状态管理以及故障恢复和一致性保证等方面的需求。逻辑时钟在分布式环境中提供了一种可靠的方式来确定事件顺序，确保Flink能够在分布式场景</p>
<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>分布式锁是一种在分布式系统中用于实现并发控制的机制。它通过对共享资源进行加锁和解锁操作，确保在分布式环境下多个节点或线程之间对资源的访问是互斥的。</p>
<p>在分布式系统中，由于多个节点或线程同时并发访问共享资源的情况，容易引发数据不一致、竞态条件和并发冲突等问题。分布式锁的目的是通过对资源进行加锁，保证在同一时刻只有一个节点或线程能够访问该资源，从而实现安全的并发控制。</p>
<p>分布式锁一般具备以下特点：</p>
<ol>
<li><p>互斥性：同一时刻只有一个节点或线程能够持有或获取锁，其他请求都需要等待。</p>
</li>
<li><p>公平性：对于多个请求同时竞争锁的情况，应保证请求的顺序和公平性，避免饥饿现象。</p>
</li>
<li><p>可重入性：同一个节点或线程可以多次获取同一把锁，而不会发生死锁。</p>
</li>
<li><p>容错性：分布式锁应该在节点故障或网络异常的情况下，能够正确释放锁，避免资源泄漏。</p>
</li>
</ol>
<p>实现分布式锁的常见方案包括使用数据库、共享存储（如ZooKeeper）、缓存（如Redis）等。通过这些方案，可以利用其特性来实现分布式锁的加锁、解锁和并发控制。</p>
<p>需要注意的是，在分布式锁的实现中，还需要关注锁的粒度、锁的持有时间和锁的释放等方面的设计。不当的设计可能会导致性能瓶颈、死锁和资源竞争等问题。因此，在使用分布式锁时，需根据具体业务需求和系统特点，选择适合的锁实现方案，并进行合理的使用和管理。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>分布式锁是用于在分布式系统中实现并发控制的重要机制。以下是几种常见的分布式锁实现方案及其优缺点：</p>
<ol>
<li><p>基于数据库的分布式锁（如MySQL）：</p>
<ul>
<li>优点：<ul>
<li>可以通过数据库事务来确保锁的原子性，避免死锁和数据不一致性。</li>
</ul>
</li>
<li>缺点：<ul>
<li>依赖于数据库的性能和可用性，数据库可能成为性能瓶颈。</li>
<li>当数据库发生故障或网络延迟时，可能导致锁的获取和释放出现问题。</li>
</ul>
</li>
</ul>
</li>
<li><p>基于共享存储（如ZooKeeper）的分布式锁：</p>
<ul>
<li>优点：<ul>
<li>ZooKeeper提供了强一致性的数据存储和分布式协调，可靠性高。</li>
<li>通过有序节点和Watch机制实现了高效的锁机制。</li>
</ul>
</li>
<li>缺点：<ul>
<li>ZooKeeper作为独立的服务，引入了额外的复杂性和维护成本。</li>
<li>对于短暂的锁操作，可能会增加额外的网络开销。</li>
</ul>
</li>
</ul>
</li>
<li><p>基于缓存（如Redis）的分布式锁：</p>
<ul>
<li>优点：<ul>
<li>Redis提供了高性能的内存数据库，适用于快速获取和释放锁。</li>
<li>可以利用Redis的原子性操作（如SETNX和EXPIRE）来实现简单而高效的锁机制。</li>
</ul>
</li>
<li>缺点：<ul>
<li>Redis是一个独立的服务，依赖于其性能和可用性。</li>
<li>对于复杂的锁场景，可能需要额外的操作和保护来确保锁的正确性。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>每种分布式锁实现方案都有其适用的场景和优缺点，具体实现的选择应根据系统需求和环境来决定。</p>
<p>需要注意的是，尽管分布式锁可以解决并发控制问题，但在使用分布式锁时，需要注意以下问题：</p>
<ul>
<li>死锁：应该避免在一个锁中一次性获取多个分布式锁，以防止死锁的发生。</li>
<li>锁竞争和性能开销：对于高并发场景，锁的争夺可能成为性能瓶颈。应尽量减少锁的持有时间，避免不必要的锁竞争。</li>
<li>锁的释放：需要确保锁的释放操作在任何情况下都能够正常执行，以避免死锁和资源泄漏。</li>
</ul>
<p>通过权衡不同分布式锁实现方案的优缺点，并根据具体业务需求做出选择，可以在分布式系统中实现有效的并发控制和资源共享。</p>
<h3 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h3><p>Redisson是基于Redis的Java客户端，提供了一套分布式锁的实现方案。其分布式锁的原理是通过Redis的原子性操作来实现并发控制，利用Redis的特性和数据结构来实现分布式锁的加锁和解锁操作。</p>
<p>具体分布式锁的实现原理如下：</p>
<ol>
<li><p>加锁操作：</p>
<ul>
<li>使用Redis的SETNX命令（SET if Not eXists）在Redis中创建一个特定的键（key）作为锁，其中键的值可以通过节点的唯一标识来区分。</li>
<li>如果SETNX命令成功，即锁创建成功，该节点获得了锁。</li>
<li>为了避免死锁问题，在加锁时可以设置过期时间，确保即使节点崩溃或锁被长期持有，锁也能够自动释放。</li>
</ul>
</li>
<li><p>解锁操作：</p>
<ul>
<li>使用Redis的DEL命令删除锁对应的键，释放锁资源。</li>
<li>在解锁操作时，需要确保只能由持有锁的节点来进行解锁，以防止其他节点意外释放锁。</li>
</ul>
</li>
</ol>
<p>Redisson还提供了红锁（RedLock）的实现，用于解决分布式系统中的主从切换问题。红锁的原理是基于多个独立的Redis实例来创建和释放锁。以下是红锁的原理：</p>
<ol>
<li><p>获取锁：</p>
<ul>
<li>客户端尝试在多个Redis实例上依次加锁，使用相同的KEY和随机的VALUE。</li>
<li>在获取锁时，客户端需要保证在大部分实例上获得锁才算成功。</li>
</ul>
</li>
<li><p>释放锁：</p>
<ul>
<li>客户端需要在加锁成功的所有实例上进行解锁操作，依次使用DEL命令删除锁对应的键。</li>
</ul>
</li>
</ol>
<p>红锁的目的是为了增加分布式锁的可靠性和容错性。即使其中一个Redis实例发生故障或主从切换，只要大多数实例正常工作，锁仍然可以正常使用。</p>
<p>需要注意的是，分布式锁虽然可以解决并发控制问题，但在使用过程中，仍需考虑锁的粒度、性能开销和故障容错等因素，并在设计和使用时进行恰当的处理和优化。</p>
<h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><p>分布式事务是指在分布式系统中涉及多个独立事务参与者的一组相关操作，这些操作要么全部成功执行，要么全部回滚，以保证事务的一致性和隔离性。</p>
<p>应用场景：</p>
<ol>
<li>跨服务操作：当一个业务操作涉及到多个服务或数据库时，需要保证这些操作同时成功或同时失败。</li>
<li>数据一致性：需要保证多个数据源（例如多个数据库）之间的数据一致性。</li>
<li>高并发场景：在高并发环境下，需要协调多个并发操作来保证数据的一致性和可靠性。</li>
</ol>
<p>实现方案：</p>
<ol>
<li><p>两阶段提交（Two-Phase Commit，2PC）：是最常用的分布式事务协议之一。涉及一个协调者和多个参与者，使用预写日志的方式确保事务在提交前进行协调和准备，然后根据协调者的指令进行事务提交或回滚。</p>
</li>
<li><p>三阶段提交（Three-Phase Commit，3PC）：在2PC的基础上进行了改进，引入了第三个阶段来解决2PC中的阻塞问题。具体为准备阶段、预提交阶段和提交阶段，通过超时机制和超时协议来解决阻塞问题，提高可用性。</p>
</li>
<li><p>XA事务（eXtended Architecture Transaction）：是一种应用层的分布式事务协议，基于事务管理器（Transaction Manager）来实现。XA协议定义了事务参与者和事务管理器之间的接口协议，通过两阶段提交协议来实现事务的一致性和隔离性。</p>
</li>
<li><p>Saga模式：是一种分布式事务的解决方案，通过将一个复杂的事务拆分成多个子事务（或称为步骤）来实现。每个子事务都可以独立执行和回滚，通过异步消息传递和补偿操作（compensating action）来保证整个事务的一致性。</p>
</li>
</ol>
<p>每种实现方案都有其优势和局限性，需要根据具体的场景和需求进行选择。2PC和3PC通常用于对一致性和可靠性要求较高的场景，而XA适用于关系型数据库的分布式事务。Saga模式则适用于业务流程较为复杂、需要较高可扩展性的场景。</p>
<p>除了前面提到的2PC、3PC、XA和Saga模式之外，还有以下几种分布式事务的方案：</p>
<ol>
<li><p>TCC（Try-Confirm-Cancel）：<br>TCC是一种基于补偿的分布式事务方案，它将事务分成尝试（Try）、确认（Confirm）和撤销（Cancel）三个阶段。在尝试阶段，执行业务预处理和资源预留；在确认阶段，确认所有的业务操作；在撤销阶段，对尝试阶段中所做的操作进行撤销。TCC通过补偿操作来保证事务的一致性。</p>
</li>
<li><p>BASE（Basically Available, Soft state, Eventually consistent）：<br>BASE是一种松散的一致性模型，与严格的事务一致性模型（ACID）相对。在BASE模型中，允许系统在一段时间内处于不一致的状态，但最终会达到一致性。BASE的目标是提高系统的可用性和性能，通过牺牲强一致性来获得更高的可靠性和可扩展性。</p>
</li>
<li><p>消息队列：<br>消息队列在分布式系统中经常用来实现异步非阻塞的事务处理。通过将事务操作转换为消息并发送到消息队列中，不同的服务可以异步地处理这些消息，并保证消息的可靠性传递。通过消息队列，可以保证数据的最终一致性，同时提高系统的性能和可伸缩性。</p>
</li>
<li><p>原子操作：<br>原子操作是指不可分割的操作，要么全部成功，要么全部失败。在分布式系统中，通过结合分布式锁和原子操作（如分布式原子计数器）来实现简单的分布式事务。这种方案适用于对一致性要求不高的场景，具有较低的实现复杂性。</p>
</li>
</ol>
<p>需要根据具体的业务需求、系统架构和复杂度来选择适合的分布式事务方案。每种方案都有其特点和适用场景，需要根据实际情况进行权衡和选择。</p>
<h2 id="分布式计算"><a href="#分布式计算" class="headerlink" title="分布式计算"></a>分布式计算</h2><p>在分布式计算框架中，通常包含以下几个核心组件：分布式计算框架、分布式任务调度和分布式计算模型。它们之间的关系如下：</p>
<ol>
<li><p>分布式计算框架（Distributed Computing Framework）：<br>分布式计算框架是指用于构建和管理分布式计算系统的软件框架。它提供了一套工具和接口，用于管理计算资源、调度任务、处理数据、处理故障等。常见的分布式计算框架有Apache Hadoop、Apache Spark、Apache Flink等。分布式计算框架负责整个分布式计算系统的运行和管理，提供高层次的抽象和接口，使得开发者可以轻松地开发和部署分布式计算应用。</p>
</li>
<li><p>分布式任务调度（Distributed Task Scheduling）：<br>分布式任务调度是指将任务分发到不同的计算节点上执行，并管理任务的调度顺序、执行状态、资源分配等。它负责将任务分解为可执行的子任务，并将子任务分配给可用的计算节点。常用的分布式任务调度器有Apache YARN、Apache Mesos、Kubernetes等。分布式任务调度器通过合理的资源分配和任务调度策略，提供高效的任务执行和优化的资源利用率。</p>
</li>
<li><p>分布式计算模型（Distributed Computing Model）：<br>分布式计算模型是用于描述和组织分布式计算任务的模型。它描述了任务之间的数据依赖关系、并行计算的方式、数据分布和通信模式等。常见的分布式计算模型有MapReduce、流计算、图计算等。这些模型提供了一种抽象的方式，使得开发者可以按照模型的规则来组织和编写分布式计算任务。分布式计算框架会通过具体的实现来支持这些计算模型，例如Hadoop支持MapReduce，Spark支持流计算和图计算等。</p>
</li>
</ol>
<p>通过分布式计算框架，可以使用分布式任务调度器将分布式计算任务分发到集群中的计算节点上执行。分布式计算模型提供了一种规范和抽象，帮助开发者组织和编写分布式计算任务。分布式计算框架通过与分布式任务调度和分布式计算模型的配合使用，实现了高效、可扩展和可靠的分布式计算。</p>
<h1 id="DevOps"><a href="#DevOps" class="headerlink" title="DevOps"></a>DevOps</h1><p>DevOps是一种软件开发和运维的方法论和实践，旨在通过强调开发人员（Development）和运维人员（Operations）之间的紧密合作和协同，以加速软件的开发、部署和运维过程，提高软件交付的速度和质量。</p>
<p>传统的软件开发和运维往往存在着互相隔离、沟通不畅、相互依赖关系紧张等问题，导致软件交付缓慢、问题频发。而DevOps的出现旨在打破这种隔离，通过改变文化、流程和工具来实现持续交付和快速响应市场需求。</p>
<p>具体来说，DevOps关注以下几个方面：</p>
<ol>
<li><p>自动化：通过自动化工具和流程，实现软件的构建、测试、部署和运维等活动的自动化，提高效率和减少错误。</p>
</li>
<li><p>协作与沟通：强调开发人员和运维人员之间的紧密合作与沟通，打破信息孤岛，共同解决问题，提高交付效率和质量。</p>
</li>
<li><p>持续集成与持续交付：采用持续集成和持续交付的理念，将小步快速迭代和频繁交付作为开发和交付的模式，从而快速响应用户需求。</p>
</li>
<li><p>自助服务：通过自助服务的方式提供必要的工具和资源，让开发人员和运维人员能够独立地进行软件开发、测试和部署等操作。</p>
</li>
<li><p>监控与反馈：建立实时监控和日志分析系统，及时获取应用程序的状态和性能数据，为持续改进和故障排查提供有价值的反馈。</p>
</li>
</ol>
<p>通过采用DevOps的方法和实践，组织可以缩短软件交付的周期、提高交付质量、增强团队的协作和创造力，更好地适应快速变化的市场需求。</p>
<h1 id="业务"><a href="#业务" class="headerlink" title="业务"></a>业务</h1><h2 id="调优指标"><a href="#调优指标" class="headerlink" title="调优指标"></a>调优指标</h2><p>以下是对这些系统速度指标的解释和使用场景的介绍：</p>
<ol>
<li>TPS（Transactions Per Second）：每秒事务数，表示系统在一秒钟内能够处理的事务或请求的数量。TPS通常用于衡量系统的吞吐量和处理能力。</li>
</ol>
<p>使用场景：</p>
<ul>
<li>在金融交易系统中，TPS可以用来衡量系统处理交易的能力。</li>
<li>在电商平台中，TPS可以用来衡量系统处理订单的能力。</li>
<li>在游戏服务器中，TPS可以用来衡量系统处理玩家请求的能力。</li>
<li>在分布式数据库中，TPS可以用来衡量系统处理数据库操作的能力。</li>
<li>在实时数据处理系统中，TPS可以用来衡量系统处理数据流的能力。</li>
</ul>
<ol start="2">
<li>HPS（Hits Per Second）：每秒命中数，表示系统在一秒钟内接收到的命中请求的数量。HPS通常用于衡量缓存系统或CDN的命中率。</li>
</ol>
<p>使用场景：</p>
<ul>
<li>在缓存系统中，HPS可以用来衡量缓存的命中率，评估缓存系统的效果。</li>
<li>在CDN（内容分发网络）中，HPS可以用来衡量CDN节点的命中率，评估CDN的性能。</li>
<li>在Web服务器中，HPS可以用来衡量页面缓存的命中率，评估网站的性能。</li>
<li>在API网关中，HPS可以用来衡量缓存API响应的命中率，评估API网关的性能。</li>
<li>在负载均衡器中，HPS可以用来衡量后端服务器的命中率，评估负载均衡的效果。</li>
</ul>
<ol start="3">
<li>QPS（Queries Per Second）：每秒查询数，表示系统在一秒钟内接收到的查询请求的数量。QPS通常用于衡量数据库或搜索引擎的查询能力。</li>
</ol>
<p>使用场景：</p>
<ul>
<li>在数据库系统中，QPS可以用来衡量数据库的查询性能，评估数据库的处理能力。</li>
<li>在搜索引擎中，QPS可以用来衡量搜索引擎的查询吞吐量，评估搜索引擎的性能。</li>
<li>在日志分析系统中，QPS可以用来衡量系统处理日志查询的能力。</li>
<li>在监控系统中，QPS可以用来衡量系统处理监控指标查询的能力。</li>
<li>在数据仓库中，QPS可以用来衡量系统处理复杂查询的能力。</li>
</ul>
<ol start="4">
<li>OPS（Operations Per Second）：每秒操作数，表示系统在一秒钟内执行的操作数量。OPS通常用于衡量系统的操作性能和处理能力。</li>
</ol>
<p>使用场景：</p>
<ul>
<li>在分布式存储系统中，OPS可以用来衡量系统的读写操作能力。</li>
<li>在消息队列系统中，OPS可以用来衡量系统处理消息的能力。</li>
<li>在日志处理系统中，OPS可以用来衡量系统处理日志记录的能力。</li>
<li>在文件系统中，OPS可以用来衡量系统处理文件读写操作的能力。</li>
<li>在分布式计算系统中，OPS可以用来衡量系统处理任务的能力。</li>
</ul>
<ol start="5">
<li>传输速率：指数据在网络中传输的速率，通常以比特&#x2F;秒（bps）或字节&#x2F;秒（Bps）为单位。传输速率用于衡量网络带宽和数据传输的效率。</li>
</ol>
<p>使用场景：</p>
<ul>
<li>在网络通信中，传输速率可以用来衡量网络连接的带宽，评估网络的传输能力。</li>
<li>在视频流媒体中，传输速率可以用来衡量视频的码率，评估视频的传输质量。</li>
<li>在文件传输中，传输速率可以用来衡量文件的传输效率，评估文件传输的速度。</li>
<li>在数据备份和恢复中，传输速率可以用来衡量数据的传输速度，评估备份和恢复的效率。</li>
<li>在云存储中，传输速率可以用来衡量数据上传和下载的速度，评估云存储的性能。</li>
</ul>
<ol start="6">
<li>包大小：指数据包的大小，通常以字节（Byte）为单位。包大小用于衡量数据传输的单个数据包的大小。</li>
</ol>
<p>使用场景：</p>
<ul>
<li>在网络通信中，包大小可以影响网络传输的效率和延迟，评估网络传输的负载情况。</li>
<li>在视频流媒体中，包大小可以影响视频的传输质量和播放的流畅性。</li>
<li>在文件传输中，包大小可以影响文件传输的速度和效率。</li>
<li>在数据备份和恢复中，包大小可以影响数据传输的速度和备份恢复的效率。</li>
<li>在云存储中，包大小可以影响数据上传和下载的速度和效率。</li>
</ul>
<p>这些指标在不同的场景中有不同的应用，根据具体的需求和系统特点，</p>
<h2 id="分布式锁效率"><a href="#分布式锁效率" class="headerlink" title="分布式锁效率"></a>分布式锁效率</h2><p>具体的吞吐量和每秒查询率（QPS）取决于多个因素，包括硬件配置、网络延迟、数据大小和查询复杂度等。因此，给出准确的数值可能有困难。以下是对三种方案的大致吞吐量和QPS的估计：</p>
<ol>
<li><p>MySQL 实现分布式锁：</p>
<ul>
<li>吞吐量：MySQL 在适当的硬件配置下，可以实现每秒数千到数万的事务吞吐量，这取决于具体的硬件和数据库优化。</li>
<li>QPS：根据吞吐量的估计，每秒查询率（QPS）可能在几千到数万之间。</li>
</ul>
</li>
<li><p>Redis 实现分布式锁：</p>
<ul>
<li>吞吐量：Redis 是一个高性能的内存数据库，可以实现每秒数十万到数百万的操作吞吐量，这主要取决于硬件配置和网络延迟。</li>
<li>QPS：根据吞吐量的估计，每秒查询率（QPS）可能在几十万到数百万之间。</li>
</ul>
</li>
<li><p>ZooKeeper 实现分布式锁：</p>
<ul>
<li>吞吐量：ZooKeeper 是一个用于分布式协调的服务，具有较高的一致性和可用性，可以实现每秒数千到数万的操作吞吐量，这取决于具体的硬件配置和网络延迟。</li>
<li>QPS：根据吞吐量的估计，每秒查询率（QPS）可能在几千到数万之间。</li>
</ul>
</li>
</ol>
<p>需要注意的是，这些估计值仅作为参考，具体的吞吐量和QPS会受到多个因素的影响，并且在不同的硬件和网络配置下可能会有所不同。对于特定的应用场景，建议使用性能测试工具来评估和测量实际的吞吐量和QPS。</p>
<h2 id="MySQL-和-ElasticSearch-检索速度"><a href="#MySQL-和-ElasticSearch-检索速度" class="headerlink" title="MySQL 和 ElasticSearch 检索速度"></a>MySQL 和 ElasticSearch 检索速度</h2><p>问：20w条数据情况下， mysql和elasticsearch的通常访问速度，吞吐量、qps是多少，请给出例子，只考虑一般情况下，不考虑集群部署<br>在只考虑一般情况下，不考虑集群部署的情况下，以下是对 MySQL 和 Elasticsearch 在20万条数据情况下的通常访问速度、吞吐量和每秒查询率（QPS）的估计：</p>
<p>MySQL:</p>
<ul>
<li>访问速度：在适当的硬件配置下，MySQL 可以实现每秒数千到数万的数据库读写请求处理能力。具体的访问速度取决于数据模型、索引设计和查询复杂性等因素。</li>
<li>吞吐量：根据访问速度的估计，MySQL 可以实现每秒数千到数万的数据库事务或查询吞吐量。</li>
<li>QPS：根据吞吐量的估计，每秒查询率（QPS）可能在几千到数万之间。</li>
</ul>
<p>Elasticsearch:</p>
<ul>
<li>访问速度：Elasticsearch 适用于全文搜索和大规模分布式场景，可以实现快速的搜索和聚合操作。在20万条数据量的情况下，通常可以实现非常快的搜索响应时间，具体速度取决于查询复杂性、索引设计和硬件配置等因素。</li>
<li>吞吐量：根据数据模型和查询复杂性等因素的影响，Elasticsearch 可以实现每秒数千到数万的查询吞吐量。</li>
<li>QPS：根据吞吐量的估计，每秒查询率（QPS）可能在几千到数万之间。</li>
</ul>
<p>需要注意的是，以上估计值仅为参考，实际的访问速度、吞吐量和QPS取决于具体的硬件和网络配置、数据模型和查询操作等因素。在实际应用中，建议使用性能测试工具进行测试和评估，并根据实际需求和环境进行调优。</p>
<p>问题：100w<br>对于简单的索引检索（不考虑复杂度）的情况，以下是对 MySQL 和 Elasticsearch 在100万条数据量下的通常访问速度、吞吐量和每秒查询率的估计：</p>
<p>MySQL:</p>
<ul>
<li>访问速度：在合适的硬件配置和适当的索引设计下，MySQL 可以实现很快的索引检索速度，通常可以在毫秒级别返回结果。</li>
<li>吞吐量：根据访问速度的估计，MySQL 可以实现每秒数千到数万次的索引检索操作。</li>
<li>QPS：根据吞吐量的估计，每秒查询率（QPS）可能在数千到数万之间。</li>
</ul>
<p>Elasticsearch:</p>
<ul>
<li>访问速度：Elasticsearch 在进行简单的索引检索时表现出色，通常能够在毫秒级别返回结果。</li>
<li>吞吐量：根据数据模型和查询复杂程度的影响，Elasticsearch 可以实现每秒数千到数万次的索引检索操作。</li>
<li>QPS：根据吞吐量的估计，每秒查询率（QPS）可能在数千到数万之间。</li>
</ul>
<p>需要注意的是，以上估计值仅为参考。实际的访问速度、吞吐量和QPS会受到具体场景中的因素影响，如硬件配置、索引设计、网络延迟等。另外，考虑到索引检索的简单性，Elasticsearch 在这种情况下可能会比MySQL表现更好，但具体效果还需根据实际测试结果评估。</p>
<h3 id="实际测试"><a href="#实际测试" class="headerlink" title="实际测试"></a>实际测试</h3><p>1：MYSQL5.7版本 产品表，7万条数据<br>2：elasticsearch6.8版本<br>3：composer 加载 下面这两个依赖，用于发送请求和连接数据库，操作ES，自己基于guzzle写</p>
<p>ES 查询，内部4（结果中的took）毫秒，代码中代码段的执行时间10ms左右；<br>MYSQL查询，内部150毫秒左右，代码中代码段的执行时间180ms左右</p>
<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h2 id="Java内存模型和jvm关系"><a href="#Java内存模型和jvm关系" class="headerlink" title="Java内存模型和jvm关系"></a>Java内存模型和jvm关系</h2><p>Java内存模型（Java Memory Model，JMM）是一种定义了Java程序如何在多线程环境下与内存进行交互的规范。JMM 定义了线程之间的通信方式、同步机制以及对变量的可见性和有序性保证等规则。</p>
<p>JVM（Java Virtual Machine）是Java程序的运行环境，负责将Java字节码转换成机器码并执行。JVM 是根据JMM规范来实现多线程并发的。</p>
<p>JMM 和 JVM 的关系如下：</p>
<ol>
<li><p>定义规范：JMM 定义了Java内存模型的规范，规定了线程和内存之间的交互方式。JMM 描述了线程如何访问变量、如何在不同线程之间通信、以及线程之间的同步机制等。</p>
</li>
<li><p>实现依赖：JVM 需要根据 JMM 的规范来实现多线程并发的功能。JVM 的实现必须遵循 JMM 的规则，以确保多线程程序的正确性和稳定性。</p>
</li>
<li><p>内存模型的具体实现：JVM 在执行 Java 程序时，在物理的计算机内存上创建虚拟的内存区域，包括堆内存、栈内存、方法区等。JVM 遵循 JMM 的规则来管理和控制线程对内存区域的操作，保证多线程并发操作的可见性、有序性和正确性。</p>
</li>
<li><p>内存屏障和同步机制：JMM 定义和规定了一些内存屏障（Memory Barrier）和同步机制，如 volatile、synchronized、Lock 等。JVM 负责具体实现这些同步机制，以实现线程之间的合理同步和数据的可见性。</p>
</li>
</ol>
<p>总结来说，JMM 是一个规范，描述了线程和内存之间的交互方式。JVM 则是根据 JMM 的规范来实现多线程并发的功能，负责管理和控制线程在内存上的操作，并提供相应的同步机制和内存屏障来保证线程的可见性、有序性和正确性。JMM 和 JVM 的结合使得 Java 在多线程环境下具有高性能、稳定性和可靠性。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs"><br><br></code></pre></td></tr></table></figure>






                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/" class="category-chain-item">分布式系统</a>
  
  
    <span>></span>
    
  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/%E5%AD%A6%E4%B9%A0/" class="category-chain-item">学习</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/">#分布式系统</a>
      
        <a href="/tags/%E5%AD%A6%E4%B9%A0/">#学习</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>ChatGPT问答</div>
      <div>http://example.com/2023/07/07/学习+疑惑/ChatGPT问答/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>where</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年7月7日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/07/08/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F-%E5%A4%A7%E6%95%B0%E6%8D%AE/%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0/" title="分布式共识算法概述">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">分布式共识算法概述</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/07/06/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%E5%92%8C%E8%A7%84%E5%88%92/" title="学习记录和规划">
                        <span class="hidden-mobile">学习记录和规划</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
